用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串(像010-12345678或0376-7654321)。

\b : 元字符 , metacharacter  , 代表单词的开头和结尾 , 也就是单词的分界处  . 虽然通常英文的单词由空格, 标点,或者换行来分隔 , 但是 \b 不匹配这些字符中的任何一个 , 它只匹配一个位置 . 
	\b匹配这样的位置：它的前一个字符和后一个字符不全是(一个是,一个不是或不存在)\w。

\d : decimal 
. : 元字符 , 匹配除了换行以外的任意一个字符 
* : 元字符 , 不表位置, 表数量 ,指定*前边的内容可以连续重复使用任意次数使得整个表达式得到匹配 
	so : .* 标示任意一串不包含换行的字符 
? : 元字符 , 表数量 , 表可以重复 0 OR 1 次 
+ : 元字符 , 表数量 , 重复 1 OR 多次 

.{2} : 前面的内容必须连续重复匹配2次
	{2,5} :  [2,5] 次 
	{n,} : 表数量 , 重复 n OR n+ 次 

\s : (半角和全角)span tab enter  / 空白字符 
\w :匹配字母 ,下划线 , 汉字等 
^ : 匹配串的开始 
& : 匹配串的结束 
  : 使用了它 后 , 匹配的是整个输入 ..  
  
	eg: 使用 \d{3} 只能验证 串里包含 \d{3}  , 
		 ^\d{3}$  可以验证整个串是否是 \d{3}  格式 !! 

[1-9] : 可以用了指定范围 : 标示其中的某个字符 
	[]  内部 , 可以包含 元字符  [.] 就尼玛直接 匹配 .  了 ~ 



反义 : 
\W : 元字符 : 匹配除了 \w 以外的字符 
\S : 元字符 : 匹配除了 \s 以外的字符 
\D : 元字符 : 匹配除了 \d 以外的字符
\B : 元字符 : 匹配除了 \b 以外的字符
[^x] :  匹配除了 x 以外的任意字符
[^xyz] : 匹配除了 xyz 以外的任意字符

	
| : 元字符 : 标示分枝 :  串1 |  串2     / 标示 串1  or 串2  
匹配 电话 (010)-88888888 /(0355)-7777777
\(?0/d{2}\)?[ -]\d{8}|\(?0\d{3}\)?[ -]\d{7,8}   // 匹配中国的电话号码 , 呵呵
		! 匹配分枝时 : 会从左到右的去测试每个条件 , 如果满足了某个分枝 , 就不去管后面的分枝了~ 
		像是美国的邮编 可以是5位数字, 也可以示连字符连接的9位数字 : 
		得写成 : \d{5}-\d{4}|\d{5} ;
		而不能是 : \d{5}|\d{5}-\d{4} ; 就只会匹配5 位的邮编和 9位邮编的前5位 ;
		
如果想要重复多个字符 : 
	用() 来指定 子表达式  / 也叫分组 
如 : 匹配ip :  ((25[0-5]|2[0-4]\d|[0-1]?\d?\d)\.){3}(25[0-5]|2[0-4]\d|[0-1]?\d?\d)	


使用小括号() 指定一个子表达式后, 匹配这个子表达式的文本(此分组捕获的内容)可以在表达式 (or其他程序中)做进一步的处理
默认情况下 每个分组会自动拥有一个组号, 从左向右 , 以分组的左括号为标志, 第一个出现的 分组号为1 ......
	组号分配是要扫描两遍的

	
-------------------------------advanced beging  


后向引用 : 用于重复搜索前面的某个子表达式分组匹配的文本  \1 代表分组1 匹配的文本  
	(\b\w+\b)\s+\1\b  // 匹配 go go 这样的重复单词 :  \1  匹配的是分组1 匹配到的内容 //注意(是内容而)不是分组1 原来的格式!
	
(? ) // 可以用这样的东东  来剥夺一个分组对组号分配的参与权 
	
自定义组名 : 	
	(?<Word>\w+)
		OR
	(?'Word'\w+)      这样就将 ()分组的name 设置为 Word           
		\b(?<Word>\w+)\b\s+\k<Word>\b。
	
 (?:exp)  不捕获匹配的文本 , 也不给该分组分配组号  exp : 正则式内容  为了性能?　
 
 // 断言用来声明一个应该为真的事实 正则表达式只有在断言为真的时候才会继续匹配 
 断言 :指定一个位置　，　该位置满足一定的条件(即断言 ) // 零宽断言
 
 
 //  零宽断言为何叫零宽 : 应为它不占用任何字符 , 只是匹配一个位置  ：　
 (?=exp) 
	eg :　\b\w+(?=ing\b)  ddd^ing // 它匹配 ^ 位置 //匹配 ddd
	// 匹配这样的位置 : 该位置位于(匹配exp的串)前面
	
(?<=exp) 
	eg :　\b\w+(?<=ing\b)  ddding^ // 它匹配 ^ 位置  //匹配 ddding
	// 匹配这样的位置 : 该位置位于(匹配exp的串)后面
	
(?!exp)  
	// 匹配这样的位置 : 该位置位于(不能匹配exp的串)前面
	eg:  \b\d{3}(?!\d)  匹配这样的位置 ：　以连续３个数字开头的串，且该串后面不是数字　
		\b((?!abc)\w)+\b   不包含 连续 abc 的单词 
		
(?<!exp) 
	// 匹配这样的位置 : 该位置位于(不能匹配exp的串)后面
	eg:  匹配前面不是小写的7位数字 :  (?<![a-z])\d{7}
	
	(?<=<(\w{1,10})>).*(?=<\/\1>)(?# in java , java要求() 里的必须为具体 , c# 就可以 (\w+)  这个匹配 html标签里的内容)
	
正则里的注释 (?# ~~~)
	
(?<=    # 断言要匹配的文本的前缀
<(\w+)> # 查找尖括号括起来的字母或数字(即HTML/XML标签)
)       # 前缀结束
.*      # 匹配任意文本
(?=     # 断言要匹配的文本的后缀
<\/\1>  # 查找尖括号括起来的内容：前面是一个"/"，后面是先前捕获的标签
)       # 后缀结束


正则默认为贪婪模式 : 即 
aaaaaaabbbbbb   用 a.*b 匹配 , 匹配到整个串 
启用 贪婪模式 a.*?b  : 匹配到 aaaaaaab
//为什么第一个匹配是aaaaaaab（第一到第三个字符）而不是ab（第二到第三个字符）？
简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权
——The match that begins earliest wins。

懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。

*? 	重复任意次，但尽可能少重复
+? 	重复1次或更多次，但尽可能少重复
?? 	重复0次或1次，但尽可能少重复
{n,m}? 	重复n到m次，但尽可能少重复
{n,}? 	重复n次以上，但尽可能少重复


处理选项；
在C#中，你可以使用Regex(String, RegexOptions)构造函数来设置正则表达式的处理选项。如：Regex regex = new Regex(@"\ba\w{6}\b", RegexOptions.IgnoreCase);

IgnoreCase(忽略大小写) 	匹配时不区分大小写。
Multiline(多行模式) 	更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.)
Singleline(单行模式) 	更改.的含义，使它与每一个字符匹配（包括换行符\n）。
IgnorePatternWhitespace(忽略空白) 	忽略表达式中的非转义空白并启用由#标记的注释。
ExplicitCapture(显式捕获) 	仅捕获已被显式命名的组。

在java中 : 


?????????

平衡组, 递归匹配 : 
这里介绍的平衡组语法是由.Net Framework支持的；其它语言／库不一定支持这种功能，或者支持此功能但需要使用不同的语法。
有时我们需要匹配像( 100 * ( 50 + 15 ) )
这样的可嵌套的层次性结构，这时简单地使用\(.+\)则只会匹配到最左边的左括号和最右边的右括号之间的内容(这里我们讨论的是贪婪模式，懒惰模式也有下面的问题)。假如原来的字符串里的左括号和右括号出现的次数不相等，比如( 5 / ( 3 + 2 ) ) )，那我们的匹配结果里两者的个数也不会相等。有没有办法在这样的字符串里匹配到最长的，配对的括号之间的内容呢？

为了避免(和\(把你的大脑彻底搞糊涂，我们还是用尖括号代替圆括号吧。现在我们的问题变成了如何把xx <aa <bbb> <bbb> aa> yy这样的字符串里，最长的配对的尖括号内的内容捕获出来？

这里需要用到以下的语法构造：

    (?'group') 把捕获的内容命名为group,并压入堆栈(Stack)
    (?'-group') 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败
    (?(group)yes|no) 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分
    (?!) 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败

如果你不是一个程序员（或者你自称程序员但是不知道堆栈是什么东西），你就这样理解上面的三种语法吧：第一个就是在黑板上写一个"group"，第二个就是从黑板上擦掉一个"group"，第三个就是看黑板上写的还有没有"group"，如果有就继续匹配yes部分，否则就匹配no部分。

我们需要做的是每碰到了左括号，就在压入一个"Open",每碰到一个右括号，就弹出一个，到了最后就看看堆栈是否为空－－如果不为空那就证明左括号比右括号多，那匹配就应该失败。正则表达式引擎会进行回溯(放弃最前面或最后面的一些字符)，尽量使整个表达式得到匹配。

<                         #最外层的左括号
    [^<>]*                #最外层的左括号后面的不是括号的内容
    (
        (
            (?'Open'<)    #碰到了左括号，在黑板上写一个"Open"
            [^<>]*       #匹配左括号后面的不是括号的内容
        )+
        (
            (?'-Open'>)   #碰到了右括号，擦掉一个"Open"
            [^<>]*        #匹配右括号后面不是括号的内容
        )+
    )*
    (?(Open)(?!))         #在遇到最外层的右括号前面，判断黑板上还有没有没擦掉的"Open"；如果还有，则匹配失败

>                         #最外层的右括号

平衡组的一个最常见的应用就是匹配HTML,下面这个例子可以匹配嵌套的<div>标签：<div[^>]*>[^<>]*(((?'Open'<div[^>]*>)[^<>]*)+((?'-Open'</div>)[^<>]*)+)*(?(Open)(?!))</div>.
	

in java ?
 
 
 Other
 in .Net : 
 \a 	报警字符(打印它的效果是电脑嘀一声)
\b 	通常是单词分界位置，但如果在字符类里使用代表退格
\t 	制表符，Tab
\r 	回车
\v 	竖向制表符
\f 	换页符
\n 	换行符
\e 	Escape
\0nn 	ASCII代码中八进制代码为nn的字符
\xnn 	ASCII代码中十六进制代码为nn的字符
\unnnn 	Unicode代码中十六进制代码为nnnn的字符
\cN 	ASCII控制字符。比如\cC代表Ctrl+C
\A 	字符串开头(类似^，但不受处理多行选项的影响)
\Z 	字符串结尾或行尾(不受处理多行选项的影响)
\z 	字符串结尾(类似$，但不受处理多行选项的影响)
\G 	当前搜索的开头
\p{name} 	Unicode中命名为name的字符类，例如\p{IsGreek}
(?>exp) 	贪婪子表达式
(?<x>-<y>exp) 	平衡组
(?im-nsx:exp) 	在子表达式exp中改变处理选项
(?im-nsx) 	为表达式后面的部分改变处理选项
(?(exp)yes|no) 	把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no
(?(exp)yes) 	同上，只是使用空表达式作为no
(?(name)yes|no) 	如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no
(?(name)yes) 	同上，只是使用空表达式作为no
 
 


	
\d{2}-(0[1-9]|11|12)-(0[1-9]|[10-31]) (0[0-9]|[10-23]):(0[0-9]|[10-59]):(0[0-9]|[10-59])$
	
	
	
	
	
	^20\d{2}-(0[1-9]|11|12)-(0[1-9]|1[1-9]|2[1-9]|3[0,1]) (0[1-9]|1[0-9]|2[0-3]):(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]):(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])$
	
	
	
	
	
	
	
 
