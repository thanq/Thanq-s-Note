非捕获分组 : // 非捕获分组 的性能 会高些 .. 
	(?:)
	
带模式修饰符的分组:
	java : (?i .. )      :  模式的切换 , 不会涉及到 分组外的其他地方 
			(?i:)
			
再次匹配先前的文本 : 
	捕获神奇日期 : 2009-09-09
	\d\d(\d\d)-\1-\1 		\1 : 反向引用 : 匹配分组1 捕获的文本 
	可以用 \1~9 来引用前9个分组 
	
正则的回溯  backtrack  
	eg : .*\d              .*会匹配到结尾 , 然后回溯一位,让后面的内容匹配去匹配...... , 
	懒惰量词 ? 也会回溯 , 但是方向不同 , 
	
消除不必要的回溯 :
	java : 使用占有量词 :
		占有量词 : 和贪心量词类似 , 但是永远不会回退  ; 可以消除那些通过回溯可能会达到的匹配
			可以在量词后加 + , 使之成为占有量词  eg :  \d*+  , ++ , {1,5}+  , ?+
		原子分组提供一样的功能
			(?>\d*)
		
				(\w++\d++) 无法匹配 abc123 ;  (?>\w+\d+)可以 , 应为 括号内部 回溯会正常发生 
				
				验证串是否匹配 <html><head></head><body></body></html>模式
					<html>.*?<head>.*?</head>.*?<body>.*?</body>.*?</html>  : O(n^5)
					<html>.*?+<head>.*?+</head>.*?+<body>.*?+</body>.*?+</html>  : O(n)

零宽断言(环视):
	JavaScript & java : 支持 (?=....) 匹配这样的位置: 他的后面是 ...
		(?!...) 他的后面不是 ... 
	
	java : (?<= ..) 匹配这样的位置: 他的前面是 ..
		他的前面不是 ...
		//向前的环视 , 性能会有问题..  , 且其中不能出现 可以匹配无穷的量词 
		
			[[\p{InThai}]&&[\P{N}]]  : 匹配泰语数字字符 
				另一种实现方式 : (?=\p{InThai})\p{N}
				
根据条件匹配两者之一 
		一个由 , 分隔的单词列表  , 要求 one 出现至少一次:
			Python :  \b(?:(?:(one)|(two)|(three))(?:,|\b)){3,}(?(1)|(?!))
				条件判断 (?(1)then|else) // 如果1分组捕获到内容 那么 then  , 如果没有 那么 else  // (?!) 这个位置的后面不是nothing , 一定匹配失败
			java / JavaScript : 分步 
			
将匹配到的内容replace 为 : $%\*$1\1           //    $1  或 \1  是 JavaScript 和 java  中对捕获分组的引用 
		java: //   $ 和 \ 需要转义     // "".replace("\\$%\\\\*\\$1\\\\1")
			$%\*$1\1  ->  \$%\\*\$1\\1  ->  \\$%\\\\*\\$1\\\\1
		javascript :// 
			'1'.replace(/\d/,"$%\\*$$1\\1")
			$%\*$1\1  ->  $%\*$$1\1  -> $%\\*$$1\\1             : JavaScript中把反斜杠 \ 当做一个字面字符 

将  http://qqq.com
				->
	<a href="http://qqq.com">http://qqq.com</a>
	// replace("http://\S+","")
	java : <a>$0</a> // 捕获 0号 分组
	javascript : <a>$&</a>  // $& 保存整个正则匹配
		
将 1234567890
	-> (123) 456-7890
	// replace :  \b(\d{3})(\d{3}\d{4})\b
	//  ($1) $2-$3