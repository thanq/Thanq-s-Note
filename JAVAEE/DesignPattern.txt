策略模式 : 用来封装算法 规则的

单一职责原则 :　就一个类而言, 应仅有一个引起他变化的原因
	如果能想到多于一个的动机去改变一个类 , 那么这个类就有多于一个的职责
	
Open for extension ; Close for modification 
	面对需求,对程序的改动是通过增加代码完成的, 而不是修改现有的代码
	
依赖倒转原则 : 细节应依赖于抽象 ; 而非抽象依赖细节 // 针对接口 , 而非实现编程 // 

高层不应依赖低层模块,两者都应该依赖抽象

装饰模式 : 为已有功能添加更多功能的一种方式 
	不修改主类 将每个用来装饰的功能放到单独的类中 并让这个类包装他所要装饰的对象 
	将 类的核心职责和装饰功能分开 去除相关类中重复的装饰逻辑 
	
里氏代换原则 : 子类型必须能够替换掉他们的父类型
		这个是开闭原则的基础

原型模式 : 让原型实例指定要创建对象的种类,并通过拷贝原型 来创建新的对象
		实现cloneable interface 就可以实现原型模式

模板方法模式 : 通过把不变的行为迁移到超类 去除子类中的重复代码和逻辑 来体现它的优势
		提供了一个代码复用平台 
		由一系列步骤构成的过程 ; 这个过程从高层次上看是相同的 , 但有些步骤的实现可能不同
			--> 就可以考虑模板方法模式了
		原本在混合着 不变和可变的 行为 的子类 中 , 不变的行为在子类中不断出现 ; 通过模板方法模式 将不变的行为搬移到
		单一的地方

迪米特法则 : ( 最小知识原则 )  
	如果两个类不必直接通信; 那么两个类就不应发生直接的相互作用 
		如果一个类要调用另一个类的某个方法  ,  可以通过第三者转发这个调用
		
何时使用外观模式 : Facade model 提供简单接口 以减少依赖
		设计初期有意识的将不同的层分离
			在层与层间建立Facade 为复杂子系统提供简单接口 使得耦合大大降低
		维护(难以维护和扩展的)遗留系统时 , 有新的需求开发依赖于它
			对于复杂的老系统,直接去改或扩展都可能产生很多问题
				可以分成两个小组
					一个开发与老系统交互的 Facade 
					另一个只需要了解 Facade提供的接口 直接开发新系统调用这些接口即可
					
建造者模式 : Builder 将复杂对象的构建与它的表示分离 使得同样的构建过程可以创建不同的表示 
	建造者模式 在当创建复杂对象的算法应该独立于该对象的组成部分以及其装配方式时 适用
	
观察者模式 : 观察者模式定义了一种一对多的依赖关系 让多个观察者对象同时监听某一个主题对象 , 当该主题对象的状态发生改变时, 会通知所有的观察者对象 , 使它们能够自动更新自己 
	将一个系统分割成一系列相互协作的类有一个很不好的副作用 :就是要维护相关对象间的一致性 ;
	我们不希望为了维持一致性而使各个类紧密耦合, 这样会给 维护, 扩展  , 和重用 带来不便
	适用: 当一个对象改变需要同时改变其他对象时 , 且不知道有多少个对象有待改变 时 应当考虑适用 观察者模式 
	当一个抽象模型有两个方面 其中一方面依赖于另一放方面 , 这时用观察者模式 可以将这两者封装在独立的对象中使他们独立的改变和复用 .
	观察者模式所做的工作就是在解除耦合, 让耦合的双方都依赖于抽象 , 而不是依赖于具体 从而使得各自的变化都不会影响另一边的变化 -- 依赖倒转原则的体现
	
	事件委托的实现 :　Observer　不用再专门的实现接口　；　减少了耦合
	
面向对象的设计其实就是希望做到代码的责任分解

状态模式 state : 当一个对象的内在状态改变时 ; 允许改变其行为 , 看起来就像该类改变了一样 
状态模式主要解决的是 : 当控制一个对象状态转换的条件表达式过于复杂时 , 把状态的判断逻辑转移到表示不同状态的一系列类当中 将复杂的判断逻辑简化 
	状态模式的好处是将与特定状态相关的行为局部化, 并且将不同状态的行为分割开来 
	它将特定状态相关的行为都放入一个对象中 , 由于所有与状态相关的代码都存在于某个 ConcreteStatu 中 所以通过定义新的子类可以很容易的增加新的状态 和 转换
	消除了庞大的条件分支语句  将各种状态转移逻辑分布到State的子类间 来减少相互间的依赖
	
	当一个对象的行为取决于它的状态, 而必须在运行时根据状态改变它的行为时 可以考虑使用状态模式
	
适配器模式 adapter : 当系统的数据和行为都正确 , 而接口不一致时 应该考虑使用适配器 目的是使控制范围之外的一个原有对象与某个接口匹配 
	主要应用于希望复用一些现存的类 , 但接口又与复用环境不一致的情况 
	


组合模式 : 定义了基本对象和组合对象的结构层次 , 基本对象可以被组合为更复制的组合对象, 而这个组合对象又可以被组合  , 如此不断递归  : 这样  程序中任何用到基本对象的地方就都可以用组合对象了 
	用户可以一致的使用组合对象和单个对象 , 不用关心到底是处理的叶子节点还是组合组件 , 不用为定义组合而写判断语句了
	
迭代器模式 : 提供一种方法顺序访问一个聚合对象中的各个元素 ; 而又不暴露该对象的内部表示 
	它分离了集合对象的遍历行为 ,抽象出一个迭代器类来负责 ,这样可以不暴露集合的内部结构, 又让外部代码透明的访问集合内部的数据
	
对象的继承关系是在编译时就确定好了的 , 所以无法在运行时改变从父类继承的实现,子类的实现与其父类的实现有非常紧密的依赖关系 , 以至于父类实现中的任何变化必然会导致子类发生变化 , 当你要复用子类时 , 如果继承下来的实现不适合解决新问题 , 则父类必须重写 或被其他更适合的类替换 : 这种依赖关系限制了灵活性 , 并最终限制了复用性 

合成/聚合原则 : 尽量使用合成/聚合 , 尽量不要使用类继承
	合成:强的 拥有 关系 : 翅膀 -> 合成 鸟 
	聚合:弱的 拥有 关系 : 鸟 -> 聚合 鸟群
	
	优先使用对象的合成/聚合 将有助于你保持每个类被封装 , 并被集中在单个任务上 , 这样类和类继承层次会保持较小规模 , 并且不太可能 增长为不可控制的庞然大物 
	
桥接模式 : 将抽象部分和它的实现部分分离 使它们可以独立变化 
	不是说让抽象类和其派生类分离 因为没有任何意义 
	实现部分指的是 抽象类及其派生类 用来实现自己的对象
	
	比如说手机既可以按照品牌分类  , 又可以按照功能分类 由于实现的方式有多种 , 桥接模式的核心意图就是把这些实现独立出来 , 让它们各自的变化 这就使得每种实现 的变化不会影响其他实现 , 从而达到应对变化的目的
	
实现系统有可能多角度分类 , 每一种分类都有可能发生变化 , 那么就把这种多角度分离出来让她们独立变化 , 减少它们间的耦合 
	比如手机 可以按照品牌来分类 , 也可以按照功能来分类 
	由于实现的方式有多种 , 桥接模式的核心意图就是把这些实现独立出来 , 让它们各自的变化  这就使得每种实现的变化不会影响其他实现 从而达到应对变化的目的 
	
命令模式 : 将一个请求封装为一个对象 , 从而你可以用不同的请求对客户进行参数化 , 对请求排队或记录日志以及支持可撤销的操作 	
	优点 :１　他能比较容易的实现一个命令队列
			２　比较容易将命令写入日志　
				３　允许接收请求的一方决定是否要否决请求
					４　容易实现对请求的撤销和重做
						５由于加入新的命令类不影响其他类，　因此增加新的具体命令类很容易　
						
	命令模式将　请求一个操作的对象　与　知道怎么执行一个操作的对象分开　
	
职责链模式 : 使多个对象都有机会接受请求 , 并将这些对象连成一条链 , 请求沿着链传递 , 直道有对象处理它为止 
	 避免请求的发送者和接收者的耦合关系
	 
	 当客户提交一个请求时 , 请求沿着链传递 , 直到有ConcreteHandler 处理它为止 
	接收者和发送者都没有对方的明确信息 , 且链中的对象自己也不知道链的结构 , 
	结果是职责链可以简化对象的相互连接 , 他们仅需要保持一个指向其后继者的引用 , 而不需要保持所有候选者的引用
	可以随时增加或修改处理一个请求的结构 , 增加了给对象指派职责的灵活性 
	一个请求很可能一直到链的末端都得不到处理 , 需要提前考虑到 

尽管将一个系统分割为很多对象 可以增加其可复用性 , 但是各个对象间的耦合 相互连接 又会降低其可复用性了 

中介者模式  用一个中介对象来封装一系列对象的交互 , 中介者使得各个对象间不必显式的调用 ,从而使其耦合松散,从而可以独立的改变他们之间的交互

	当系统中出现了很多多对多 交互复制的对象时 , 不用急于使用 中介者模式 , 而先反思你的系统在设计上是不是合理 
	
	由于ConcreteMediator 控制了集中化 , 于是就把交互的复杂性 变为了中介者的复杂性 ,使得中介者比任意 ConcretColleague 更复杂 
	
	中介者模式一般应用于一组对象以定义良好但复杂的方式进行通信的场合  比如窗体控件间的通信  , 或定制一个分布在多个类中的行为 , 又不想生成太多子类的场合 
	
享元模式 用共享技术有效的支持大量细粒度的对象 
享元模式可以避免大量非常相似类的开销 . 有时需要生成大量细粒度的类实例来表示数据 
如果发现这些实例 除了几个参数外基本都是相同的 就能大幅度减少需要实例化的类的数量 
如果可以把参数移到类实例的外面  在方法调用时将他们传递过来, 就可以通过共享大幅度减少单个实例的数目 

如果一个程序使用了大量的对象 而大量的这些对象造成了很大的存储开销时 , 就可以考虑使用享元模式 
如果对象的大多数状态可以是外部状态 , 如果删除对象的外部状态就可以 用 享元模式 使用相对较少的共享对象取代很多组对象 


解释器模式 : 给定一个语言 ,定义它的文法的一种表示 并定义一个解释器 , 用该解释器表示解释语言中的句子 
	当一种特定问题发生的频率足够高 就可以将该问题的各个实例表述为一个简单语言中的句子 . 这样就可以构建一个解释器 ,通过解释器解释这些句子来解决问题 
	 
	// 著名应用 : 正则表达式 
	
访问者模式 : 表示一个作用于某对象结构中的各元素的操作  他使你可以在不改变各个元素的类的前提下定义作用于这些元素的新操作 

访问者模式适用于数据结构稳定的系统 它把数据结构和作用在结构上的操作解耦 使得操作集合可以相对自由的演化 

访问者模式的目的是要把处理从数据结构中分离出来 
如果系统有很稳定的数据结构 , 和易于变化的算法时 : 使用访问者模式是比较适合的 因为访问者模式使得算法操作的增加变得容易 

访问者模式的优点就是 增加新的操作比较容易 , 添加一个新的访问者就可以了 
访问者模式将有关的行为集中到一个访问者对象中 
访问者的缺点 : 使得增加新的数据结构变得困难 


	
	



? java 模拟 表单提交 
 		